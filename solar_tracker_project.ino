#include <Servo.h>
#include <LiquidCrystal.h>

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

Servo pan;    // create servo object to control the yaw servo
Servo tilt;  // create servo object to control the pitch servo

/*---------------------------------------- CONSTANTS ----------------------------------------*/
// Modes
#define DEBUG_MODE_ON 1
#define DAQ_MODE_ON 0

// Hill-climbing algorithm: constants
#define MIN_DIFF 30
#define STEP_DIVIDER 30
#define ANALOG_READ_DELAY 100

// Number of measurements for the light
// intiensities to compute the average from
#define NO_MEASUREMENTS 5

// Pins
int pinPhotoResistorS = A9;
int pinPhotoResistorN = A8;
int pinPhotoResistorE = A11;
int pinPhotoResistorW = A10;

int solarPanelVoltagePin = A15;

int panPin = 31;
int tiltPin = 30;

int sensorModeBtn = 20;
int searchModeBtn = 21;

// Motor constants
#define MIN_TILT 5
#define MAX_TILT 75
#define MIN_PAN 5
#define MAX_PAN 175

// increments for broad search
#define TILT_INC_BROAD 10
#define PAN_INC_BROAD 20
// increments for restricted search
#define TILT_INC_RESTR 10
#define PAN_INC_RESTR 10
// to define restricted search area
#define RESTR_SEARCH_AREA_TILT 40
#define RESTR_SEARCH_AREA_PAN 30
#define SEARCH_STEP_DELAY 500

/*------------------------------------- Application State -------------------------------------*/

// Data structures for the application's state
struct MotorPositions {
  int panAngle = 90;
  int tiltAngle = 90;
};

struct LightIntensityData {
  int S = 0;
  int N = 0;
  int E = 0;
  int W = 0;
};

//application working mode
enum Mode {
  sensorMode,
  searchMode
};

volatile Mode mode = sensorMode;
volatile Mode previousMode = mode;

LightIntensityData lightIntData;
MotorPositions motorPos, prevMotorPos, maxVoltageMotorPos;
double voltage = 0.0;
double max_voltage = 0.0;

// Loop counter, for the DAQ verification purposes
int loop_counter = 0;

//used to perform searches at a specified interval
unsigned long previousMillis = 0;
const long interval = 20000; // 20 second interval bteween restricted searches

//used to initalize the search mode with a broad search
bool initialize_broad_search = true;

/* ---- display ---- */

// compass: left, up, down arrows
byte compass[3][8] = {
  // left arrow
  {B00000, B00000, B00000, B00100, B01100, B11111, B01100, B00100},
  // up arrow
  {B00100, B01110, B11111, B00100, B00100, B00100, B00100, B00000},
  // right arrow
  {B00000, B00000, B00000, B00100, B00110, B11111, B00110, B00100}
};

byte sensor[3][8] = {
  {B00000, B00000, B00001, B00010, B00100, B00001, B00010, B00000},
  {B00000, B10101, B00000, B01010, B10001, B00000, B00100, B01110},
  {B00000, B00000, B10000, B01000, B00100, B10000, B01000, B00000}
};

int sensorAddr[] = {0, 1, 2};
int compassAddr[] = {3, 4, 5};

/*-------------------------------------------- Setup --------------------------------------------*/
void setup() {

  // setup pins for photoresistors
  pinMode(pinPhotoResistorN, INPUT);
  pinMode(pinPhotoResistorS, INPUT);
  pinMode(pinPhotoResistorE, INPUT);
  pinMode(pinPhotoResistorW, INPUT);

  // setup the pin for the solar panel
  pinMode(solarPanelVoltagePin, INPUT);

  // setup pins for servo motors
  pan.attach(panPin);   // attaches the servo on pin 2 to the servo object
  tilt.attach(tiltPin);  // attaches the servo on pin 3 to the servo object

  if (DEBUG_MODE_ON) {
    DebugModeSetup();
  } else if (DAQ_MODE_ON) {
    DAQModeSetup();
  }

  // setup display
  setup_display();

  displayModeOnLCD();

  // setup buttons
  setup_buttons();
}

/*--------------------------------------------- Loop ---------------------------------------------*/
void loop() {
  loop_counter++;

  if (previousMode != mode) {
    previousMode = mode;
    displayModeOnLCD();
    initialize_broad_search = true;
  }

  switch (mode) {
    case sensorMode : {
        // reading the photoresistor values (introduces a delay in the loop)
        lightIntData = readLightIntensities();
        // measure voltage generated by the solar panel
        voltage = readSolarPanelVoltage();

        // finding the new motor positions
        prevMotorPos = motorPos;
        motorPos = computeNewMotorAngles(prevMotorPos, lightIntData);
        // move motors to the new angles, if a change occured
        updateMotorAngles();
        outputData();
        break;
      }
    case searchMode : {
        if (initialize_broad_search) {
          initialize_broad_search = false;
          maxVoltageMotorPos = performSearch(MIN_PAN, MIN_TILT, MAX_PAN, MAX_TILT, TILT_INC_BROAD, PAN_INC_BROAD);
          motorPos = maxVoltageMotorPos;
          updateMotorAngles();
          outputData();
          previousMillis = millis();
        } else {
          unsigned long currentMillis = millis(); // used to have an interval of time between searches
          if (currentMillis - previousMillis >= interval) {
            // we will make a more restricted search since we supppose the light won't move very much
            // from the initial position
            maxVoltageMotorPos = performSearch(motorPos.panAngle - RESTR_SEARCH_AREA_PAN,
                                               motorPos.tiltAngle - RESTR_SEARCH_AREA_TILT,
                                               motorPos.panAngle + RESTR_SEARCH_AREA_PAN,
                                               motorPos.tiltAngle + RESTR_SEARCH_AREA_TILT, TILT_INC_RESTR, PAN_INC_RESTR);
            motorPos = maxVoltageMotorPos;
            updateMotorAngles();
            outputData();
            previousMillis = millis();
          }
          else {
            //delay(50);
          }
        }
        break;
      }
  }
}

/*--------------------------------------- Reading the Sensors ---------------------------------------*/
LightIntensityData readLightIntensities() {
  LightIntensityData result;

  int lightIntensityS, lightIntensityN, lightIntensityE, lightIntensityW;

  for (int i = 0; i < NO_MEASUREMENTS; i++) {
    lightIntensityS = analogRead(pinPhotoResistorS);
    delay(ANALOG_READ_DELAY);
    lightIntensityN = analogRead(pinPhotoResistorN);
    delay(ANALOG_READ_DELAY);
    lightIntensityE = analogRead(pinPhotoResistorE);
    delay(ANALOG_READ_DELAY);
    lightIntensityW = analogRead(pinPhotoResistorW);
    delay(ANALOG_READ_DELAY);

    result.S += lightIntensityS;
    result.N += lightIntensityN;
    result.E += lightIntensityE;
    result.W += lightIntensityW;
  }

  result.S /= NO_MEASUREMENTS;
  result.E /= NO_MEASUREMENTS;
  result.W /= NO_MEASUREMENTS;
  result.N /= NO_MEASUREMENTS;

  return result;
}

double readSolarPanelVoltage() {
  int digitalValue = analogRead(solarPanelVoltagePin);
  double analogVoltageValue = digitalValue * 5.0 / 1023.0;
  return analogVoltageValue;
}

/*------------------------------------ Repositioning the motors -----------------------------------*/
MotorPositions computeNewMotorAngles(MotorPositions prevPos, LightIntensityData lightIntData) {
  MotorPositions resultPos;
  resultPos.tiltAngle = prevPos.tiltAngle;
  resultPos.panAngle = prevPos.panAngle;

  // compute new angles
  int SNdirectionDiff = lightIntData.S - lightIntData.N;
  if (abs(SNdirectionDiff) >= MIN_DIFF) {
    resultPos.tiltAngle = max(MIN_TILT, min(MAX_TILT, prevPos.tiltAngle + SNdirectionDiff / STEP_DIVIDER));
  }

  int EWdirectionDiff = lightIntData.E - lightIntData.W;
  if (abs(EWdirectionDiff) >= MIN_DIFF) {
    resultPos.panAngle = max(MIN_PAN, min(MAX_PAN, prevPos.panAngle + EWdirectionDiff / STEP_DIVIDER));
  }

  return resultPos;
}

MotorPositions performSearch(int pan_start, int tilt_start, int pan_end, int tilt_end, int tilt_increment, int pan_increment) {
  maxVoltageMotorPos.panAngle = pan_start;
  maxVoltageMotorPos.tiltAngle = tilt_start;
  max_voltage = 0.0;
  bool moving_pan_left_to_right = true;
  bool continue_moving_pan = true;
  int pan_pos = pan_start;

  //make sure not to exceed the limits
  if (tilt_start < MIN_TILT) {
    tilt_start = MIN_TILT;
  }
  if (tilt_end > MAX_TILT) {
    tilt_end = MAX_TILT;
  }
  if (pan_start < MIN_PAN) {
    pan_start = MIN_PAN;
  }
  if (pan_end > MAX_PAN) {
    pan_end = MAX_PAN;
  }

  for (int tilt_pos = tilt_start; tilt_pos <= tilt_end; tilt_pos += tilt_increment) {
//    if (previousMode != mode) {
//      break;
//    }
    tilt.write(tilt_pos);
    while (continue_moving_pan) {
//      if (previousMode != mode) {
//        break;
//      }
      pan.write(pan_pos);
      double current_voltage = readSolarPanelVoltage();

      //print
      debugForMode2();

      //identify is this is the max voltage
      if (current_voltage > max_voltage) {
        maxVoltageMotorPos.panAngle = pan_pos;
        maxVoltageMotorPos.tiltAngle = tilt_pos;
        max_voltage = current_voltage;
      }
      if (moving_pan_left_to_right) {
        pan_pos += pan_increment;
        if (pan_pos >= pan_end) {
          continue_moving_pan = false;
        }
      } else { //once the pan reaches far right we will move from right to left to use less resources
        pan_pos -= pan_increment;
        if (pan_pos <= pan_start) {
          continue_moving_pan = false;
        }
      }
      delay(SEARCH_STEP_DELAY); // delay between next move and measure
    }
    moving_pan_left_to_right = !moving_pan_left_to_right;
    continue_moving_pan = true;
    delay(SEARCH_STEP_DELAY);
  }
  return maxVoltageMotorPos;
}

void updateMotorAngles() {
  // move motors to the new angles, if a change occured
  if (motorPos.panAngle != prevMotorPos.panAngle) {
    pan.write(motorPos.panAngle);
  }

  delay(100);
  
  if (motorPos.tiltAngle != prevMotorPos.tiltAngle) {
    tilt.write(motorPos.tiltAngle);
  }
}

/*-------------- Data Aquisition (relying on PLX-DAQ)over Serial, for plotting ---------------------*/
void DAQModeSetup() {
  String TABLE_HEADER = "LABEL,Date,Time,Timer,Counter,"
                        "LightInt_South,LightInt_North,LightInt_East,LightInt_West,"
                        "Motor_Pan,Motor_Tilt,"
                        "Voltage";
  Serial.begin(9600);
  Serial.println("CLEARSHEET");
  Serial.println(TABLE_HEADER);
}

void DAQSendDataOverSerial() {
  Serial.println( (String) "DATA,DATE,TIME,TIMER," + loop_counter + "," +
                  lightIntData.S + "," + lightIntData.N + "," + lightIntData.E+"," + lightIntData.W + "," +
                  motorPos.panAngle + "," + motorPos.tiltAngle + "," + voltage);
}

/*-------------------------- Debug Mode (display data on Serial Monitor) ---------------------------*/
void DebugModeSetup() {
  Serial.begin(9600);
}

void DebugSendDataOverSerial() {
  // display data for debugging purposes
  Serial.println((String) "-----------Loop " + loop_counter + "-----------------");
  Serial.println("---Light Intensities (values given by the ADC)");
  Serial.println((String) "S=" + lightIntData.S + ", N=" + lightIntData.N +
                 ", E=" + lightIntData.E + ", W=" + lightIntData.W);

  Serial.println("---Motor positions: ");
  Serial.println((String) "PanAngle=" + motorPos.panAngle + ", TiltAngle=" + motorPos.tiltAngle);

  Serial.println("---Voltage: ");
  Serial.println((String) voltage + "V");
}

void debugForMode2() {
  Serial.println("---Motor positions: ");
  Serial.println((String) "PanAngle=" + motorPos.panAngle + ", TiltAngle=" + motorPos.tiltAngle);

  Serial.println("---Voltage: ");
  Serial.println((String) voltage + "V");
}

/*-------------------------- Output Data ---------------------------*/
void outputData() {
  // send data over the serial port for daq/debugging purposes
  if (DEBUG_MODE_ON) {
    DebugSendDataOverSerial();
  } else if (DAQ_MODE_ON) {
    DAQSendDataOverSerial();
  }
}

/* --------------------------- Display -------------------------------- */

void setup_display() {
  //--------------> initialize LCD <-----------------
  lcd.begin(16, 2);
  //-----------> create custom characters <----------
  for (int i = 0; i < 3; i++) {
    lcd.createChar(i, sensor[i]);
  }
  for (int i = 0; i < 3; i++) {
    lcd.createChar(3 + i, compass[i]);
  }
}

/**
   Display the current mode on the LCD.
*/

void displayModeOnLCD() {
  lcd.clear();
  lcd.setCursor(0, 1);
  switch (mode) {
    case sensorMode : {
        lcd.print ("sensors ");
        for (int i = 0; i < 3; i++) {
          lcd.write (byte(sensorAddr[i]));
        }
        break;
      }
    case searchMode : {
        lcd.print ("search ");
        for (int i = 0; i < 3; i++) {
          lcd.write (byte(compassAddr[i]));
        }
        break;
      }
  }
}

/* --------------------------- Buttons -------------------------------- */
void setup_buttons() {
  //----------------> configure buttons <--------------
  pinMode(sensorModeBtn, INPUT_PULLUP);
  pinMode(searchModeBtn, INPUT_PULLUP);
  //-----------> attach interrupts to buttons <----------
  attachInterrupt(digitalPinToInterrupt(sensorModeBtn), onSwitchToSensorMode, FALLING);
  attachInterrupt(digitalPinToInterrupt(searchModeBtn), onSwitchToSearchMode, FALLING);
}

/**
   Callback functions to change the functioning mode of the solar tracker when an interrupt is triggered.
*/

void onSwitchToSensorMode() {
  previousMode = mode;
  mode = sensorMode;
}

void onSwitchToSearchMode() {
  previousMode = mode;
  mode = searchMode;
}
